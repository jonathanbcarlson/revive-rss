<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Morning Paper</title><id>https://blog.acolyer.org/</id><updated>2023-04-14T06:03:06.609159824+00:00</updated><author><name>Adrian Colyer</name></author><icon>https://secure.gravatar.com/blavatar/09326a066a08237015d6b84f026d36ae?s=32</icon><entry><title>Kraken: Leveraging live traffic tests to identify and resolve resource utilization bottlenecks in large scale web services</title><id>https://blog.acolyer.org/2016/11/28/kraken-leveraging-live-traffic-tests-to-identify-and-resolve-resource-utilization-bottlenecks-in-large-scale-web-services/</id><updated>2024-06-13T15:13:17.604622348+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/11/28/kraken-leveraging-live-traffic-tests-to-identify-and-resolve-resource-utilization-bottlenecks-in-large-scale-web-services/" rel="alternate"/><content>Kraken: Leveraging live traffic tests to identify and resolve resource utilization bottlenecks in large scale web services</content></entry><entry><title>Early detection of configuration errors to reduce failure damage</title><id>https://blog.acolyer.org/2016/11/29/early-detection-of-configuration-errors-to-reduce-failure-damage/</id><updated>2024-06-14T15:14:21.169646822+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/11/29/early-detection-of-configuration-errors-to-reduce-failure-damage/" rel="alternate"/><content>Early detection of configuration errors to reduce failure damage</content></entry><entry><title>Firmament: Fast, centralized cluster scheduling at scale</title><id>https://blog.acolyer.org/2016/11/30/firmament-fast-centralized-cluster-scheduling-at-scale/</id><updated>2024-06-15T15:13:12.788990843+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/11/30/firmament-fast-centralized-cluster-scheduling-at-scale/" rel="alternate"/><content>Firmament: Fast, centralized cluster scheduling at scale</content></entry><entry><title>Morpheus: Towards automated SLOs for enterprise clusters</title><id>https://blog.acolyer.org/2016/12/01/morpheus-towards-automated-slos-for-enterprise-clusters/</id><updated>2024-06-16T15:12:50.470417436+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/01/morpheus-towards-automated-slos-for-enterprise-clusters/" rel="alternate"/><content>Morpheus: Towards automated SLOs for enterprise clusters</content></entry><entry><title>Slicer: Auto-sharding for datacenter applications</title><id>https://blog.acolyer.org/2016/12/02/slicer-auto-sharding-for-datacenter-applications/</id><updated>2024-06-17T15:14:00.908967253+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/02/slicer-auto-sharding-for-datacenter-applications/" rel="alternate"/><content>Slicer: Auto-sharding for datacenter applications</content></entry><entry><title>REX: A development platform and online learning approach for runtime emergent software systems</title><id>https://blog.acolyer.org/2016/12/05/rex-a-development-platform-and-online-learning-approach-for-runtime-emergent-software-systems/</id><updated>2024-06-18T15:12:55.770342436+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/05/rex-a-development-platform-and-online-learning-approach-for-runtime-emergent-software-systems/" rel="alternate"/><content>REX: A development platform and online learning approach for runtime emergent software systems</content></entry><entry><title>The SNOW theorem and latency-optimal read-only transactions</title><id>https://blog.acolyer.org/2016/12/06/the-snow-theorem-and-latency-optimal-read-only-transactions/</id><updated>2024-06-19T15:13:44.246022139+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/06/the-snow-theorem-and-latency-optimal-read-only-transactions/" rel="alternate"/><content>The SNOW theorem and latency-optimal read-only transactions</content></entry><entry><title>Interlude: On assumptions</title><id>https://blog.acolyer.org/2016/12/07/interlude-on-assumptions/</id><updated>2024-06-20T15:14:05.655778539+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/07/interlude-on-assumptions/" rel="alternate"/><content>Interlude: On assumptions</content></entry><entry><title>Just say NO to Paxos overhead: replacing consensus with network ordering</title><id>https://blog.acolyer.org/2016/12/08/just-say-no-to-paxos-overhead-replacing-consensus-with-network-ordering/</id><updated>2024-06-21T15:17:30.160027292+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/08/just-say-no-to-paxos-overhead-replacing-consensus-with-network-ordering/" rel="alternate"/><content>Just say NO to Paxos overhead: replacing consensus with network ordering</content></entry><entry><title>DQBarge: Improving data-quality tradeoffs in large-scale internet services</title><id>https://blog.acolyer.org/2016/12/09/dqbarge-improving-data-quality-tradeoffs-in-large-scale-internet-services/</id><updated>2024-06-22T15:12:41.243047051+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2016/12/09/dqbarge-improving-data-quality-tradeoffs-in-large-scale-internet-services/" rel="alternate"/><content>DQBarge: Improving data-quality tradeoffs in large-scale internet services</content></entry></feed>