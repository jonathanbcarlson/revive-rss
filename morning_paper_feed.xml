<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Morning Paper</title><id>https://blog.acolyer.org/</id><updated>2023-04-14T06:03:06.609159824+00:00</updated><author><name>Adrian Colyer</name></author><icon>https://secure.gravatar.com/blavatar/09326a066a08237015d6b84f026d36ae?s=32</icon><entry><title>Programming and proving with distributed protocols</title><id>https://blog.acolyer.org/2018/01/22/programming-and-proving-with-distributed-protocols/</id><updated>2025-02-21T15:14:46.988933614+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/22/programming-and-proving-with-distributed-protocols/" rel="alternate"/><content>Programming and proving with distributed protocols</content></entry><entry><title>Why is random testing effective for partition tolerance bugs?</title><id>https://blog.acolyer.org/2018/01/23/why-is-random-testing-effective-for-partition-tolerance-bugs/</id><updated>2025-02-22T15:12:55.395443986+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/23/why-is-random-testing-effective-for-partition-tolerance-bugs/" rel="alternate"/><content>Why is random testing effective for partition tolerance bugs?</content></entry><entry><title>Linear Haskell: Practical linearity in a higher-order polymorphic language</title><id>https://blog.acolyer.org/2018/01/24/linear-haskell-practical-linearity-in-a-higher-order-polymorphic-language/</id><updated>2025-02-23T15:12:53.227200141+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/24/linear-haskell-practical-linearity-in-a-higher-order-polymorphic-language/" rel="alternate"/><content>Linear Haskell: Practical linearity in a higher-order polymorphic language</content></entry><entry><title>A static verification framework for message passing in Go using behavioural types</title><id>https://blog.acolyer.org/2018/01/25/a-static-verification-framework-for-message-passing-in-go-using-behavioural-types/</id><updated>2025-02-24T15:16:47.505131467+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/25/a-static-verification-framework-for-message-passing-in-go-using-behavioural-types/" rel="alternate"/><content>A static verification framework for message passing in Go using behavioural types</content></entry><entry><title>A practitioner’s guide to reading programming languages papers</title><id>https://blog.acolyer.org/2018/01/26/a-practitioners-guide-to-reading-programming-languages-papers/</id><updated>2025-02-25T15:16:10.723691681+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/26/a-practitioners-guide-to-reading-programming-languages-papers/" rel="alternate"/><content>A practitioner’s guide to reading programming languages papers</content></entry><entry><title>The paradigms of programming</title><id>https://blog.acolyer.org/2018/01/29/the-paradigms-of-programming/</id><updated>2025-02-26T15:16:17.959969286+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/29/the-paradigms-of-programming/" rel="alternate"/><content>The paradigms of programming</content></entry><entry><title>A theory of the learnable</title><id>https://blog.acolyer.org/2018/01/31/a-theory-of-the-learnable/</id><updated>2025-02-27T15:16:33.133900981+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/01/31/a-theory-of-the-learnable/" rel="alternate"/><content>A theory of the learnable</content></entry><entry><title>Learning representations by back-propagating errors</title><id>https://blog.acolyer.org/2018/02/01/learning-representations-by-back-propagating-errors/</id><updated>2025-02-28T15:15:19.681857894+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/02/01/learning-representations-by-back-propagating-errors/" rel="alternate"/><content>Learning representations by back-propagating errors</content></entry><entry><title>Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer</title><id>https://blog.acolyer.org/2018/02/02/polynomial-time-algorithms-for-prime-factorization-and-discrete-logarithms-on-a-quantum-computer/</id><updated>2025-03-01T15:13:40.912161382+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/02/02/polynomial-time-algorithms-for-prime-factorization-and-discrete-logarithms-on-a-quantum-computer/" rel="alternate"/><content>Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer</content></entry><entry><title>Quantum computing in the NISQ era and beyond</title><id>https://blog.acolyer.org/2018/02/05/quantum-computing-in-the-nisq-era-and-beyond/</id><updated>2025-03-02T15:14:23.206810696+00:00</updated><author><name>Adrian Colyer</name></author><link href="https://blog.acolyer.org/2018/02/05/quantum-computing-in-the-nisq-era-and-beyond/" rel="alternate"/><content>Quantum computing in the NISQ era and beyond</content></entry></feed>